(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{424:function(v,_,t){"use strict";t.r(_);var e=t(42),r=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"原理部分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原理部分"}},[v._v("#")]),v._v(" 原理部分")]),v._v(" "),t("h2",{attrs:{id:"浏览器的渲染机制和原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的渲染机制和原理"}},[v._v("#")]),v._v(" 浏览器的渲染机制和原理")]),v._v(" "),t("p",[v._v("当我们在浏览器地址栏中键入一个地址，然后按下回车，此时一个请求便开始了。")]),v._v(" "),t("p",[v._v("这个过程分成两个阶段：")]),v._v(" "),t("ul",[t("li",[v._v("请求阶段：负责从服务器获取内容")]),v._v(" "),t("li",[v._v("渲染阶段：负责将获取到的内容呈现在浏览器中")])]),v._v(" "),t("h3",{attrs:{id:"请求阶段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#请求阶段"}},[v._v("#")]),v._v(" 请求阶段")]),v._v(" "),t("p",[v._v("1、当客户端开输入一个网址后，会向服务器发送一个 "),t("RouterLink",{attrs:{to:"/roadmap/frontend/advanced/network.html#请求-request"}},[v._v("Request 请求")]),v._v("，首先需要 "),t("code",[v._v("DNS")]),v._v(" 解析，然后进行 "),t("code",[v._v("TCP")]),v._v(" 连接。")],1),v._v(" "),t("p",[v._v("2、服务器收到请求后，会发送一个 "),t("RouterLink",{attrs:{to:"/roadmap/frontend/advanced/network.html#响应-response"}},[v._v("Response 响应")]),v._v("给客户端，并将文件内容返回给客户端。")],1),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[v._v("说明")]),v._v(" "),t("p",[t("RouterLink",{attrs:{to:"/roadmap/frontend/advanced/network.html#http"}},[v._v("实际请求")]),v._v("要比上述过程更加繁琐，但并不影响对于渲染的理解。")],1)]),v._v(" "),t("h3",{attrs:{id:"渲染阶段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#渲染阶段"}},[v._v("#")]),v._v(" 渲染阶段")]),v._v(" "),t("p",[v._v("1、客户端拿到页面内容后，浏览器会在内存中开辟一块"),t("strong",[v._v("栈内存")]),v._v("，用来给代码的执行提供环境，同时分配一个主线程一行一行解析和执行代码。")]),v._v(" "),t("blockquote",[t("p",[v._v("因为 "),t("code",[v._v("JavaScript")]),v._v(" 是单线程，所以每执行完一条语句，都需要执行出栈操作，然后将下一条语句执行进栈操作")])]),v._v(" "),t("p",[v._v("2、当浏览器遇到 "),t("code",[v._v("link")]),v._v("、"),t("code",[v._v("script")]),v._v("、"),t("code",[v._v("img")]),v._v("、"),t("code",[v._v("video")]),v._v(" 等资源请求，都会开辟一个全新的线程去加载资源文件，这个全新的线程叫 "),t("strong",[v._v("任务队列（Task Queue）")]),v._v("。")]),v._v(" "),t("p",[v._v("3、当主文件（不包含资源文件）第一次自上而下加载完成后，会生成 "),t("code",[v._v("DOM-Tree")]),v._v("。")]),v._v(" "),t("p",[v._v("4、加载完 "),t("code",[v._v("DOM-Tree")]),v._v(" 后，浏览器会去"),t("strong",[v._v("任务队列")]),v._v("循环查看那些任务已经完成，然后将已完成的任务一个一个插入到 "),t("code",[v._v("DOM-Tree")]),v._v(" 中，知道所有任务全部完成。这叫 "),t("strong",[v._v("事件循环（Event Loop）")]),v._v("。")]),v._v(" "),t("blockquote",[t("p",[v._v("任务队列又分成 "),t("strong",[v._v("微任务")]),v._v(" 和 "),t("strong",[v._v("宏任务")]),v._v("，"),t("strong",[v._v("微任务")]),v._v(" 的优先级高于 "),t("strong",[v._v("宏任务")])])]),v._v(" "),t("p",[v._v("5、当 CSS 处理完成后，会生成 "),t("code",[v._v("CSSOM")]),v._v("，浏览器会将 "),t("code",[v._v("DOM-Tree")]),v._v(" 与 "),t("code",[v._v("CSSOM")]),v._v(" 合并成一个 "),t("strong",[v._v("渲染树（Render Tree）")]),v._v("。")]),v._v(" "),t("p",[v._v("6、回流。浏览器根据生成的 "),t("code",[v._v("Render Tree")]),v._v("，计算它们在设备视口内的确切位置和大小，这个计算阶段叫做 "),t("strong",[v._v("回流（Reflow）")]),v._v("。")]),v._v(" "),t("p",[v._v("7、重绘。根据 "),t("code",[v._v("Render Tree")]),v._v(" 以及 "),t("strong",[v._v("回流")]),v._v(" 得到的几何信息，得到节点的绝对像素，这个阶段叫做 "),t("strong",[v._v("重绘（Repaint）")]),v._v("。")]),v._v(" "),t("blockquote",[t("p",[v._v("在首次加载阶段，一定会发生 "),t("strong",[v._v("回流")]),v._v(" 和 "),t("strong",[v._v("重绘")]),v._v("，并且一定先 "),t("strong",[v._v("回流")]),v._v(" 再 "),t("strong",[v._v("重绘")])])]),v._v(" "),t("p",[v._v("8、最后，浏览器会调用 GPU 进行图形渲染，将 "),t("code",[v._v("Render Tree")]),v._v(" 的内容渲染并展示给用户。")]),v._v(" "),t("img",{attrs:{src:v.$withBase("/assets/roadmap/frontend/render-process.png"),alt:""}})])}),[],!1,null,null,null);_.default=r.exports}}]);